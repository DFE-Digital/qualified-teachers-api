name: Build

on:
  push:
    branches:
    - main
    paths-ignore:
    - 'docs/**'
    - 'README.md'
    - 'LICENSE'
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches:
    - main
    paths-ignore:
    - 'docs/**'
    - 'README.md'
    - 'LICENSE'

env:
  CONTAINER_REGISTRY: ghcr.io

jobs:
  build:
    name: Build & test
    runs-on: ubuntu-latest
    concurrency: build

    outputs:
      docker_image: ${{ steps.image.outputs.tag }}

    services:
      postgres:
        image: postgres
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: dqt
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v2

    - uses: actions/setup-dotnet@v1
      with:
        dotnet-version: '6.0.x'

    - name: Build
      run: dotnet build --configuration Release

    - name: Test
      id: test
      run: dotnet test tests/DqtApi.Tests --configuration Release --no-build --logger trx
      env:
        IntegrationTests_CrmUrl: ${{ secrets.IntegrationTests_CrmUrl }}
        IntegrationTests_CrmClientId: ${{ secrets.IntegrationTests_CrmClientId }}
        IntegrationTests_CrmClientSecret: ${{ secrets.IntegrationTests_CrmClientSecret }}
        ConnectionStrings__DefaultConnection: "Host=localhost;Username=postgres;Password=${{ secrets.POSTGRES_PASSWORD }};Database=dqt"

    - name: Test report
      uses: dorny/test-reporter@v1
      if: ${{ steps.test.outcome != 'skipped' }}
      with:
        name: Test results
        path: "**/*.trx"
        reporter: dotnet-trx

    # TODO Use migration bundles when https://github.com/dotnet/efcore/issues/25555 is fixed
    - name: Generate migrations artifact
      run: |
        mkdir migrations
        dotnet tool install --global dotnet-ef
        dotnet ef migrations script --idempotent --output migrations/script.sql --configuration Release --project src/DqtApi/DqtApi.csproj --no-build

    - name: Publish migrations
      uses: actions/upload-artifact@v2
      with:
        name: migrations
        path: migrations

    - name: Publish
      run: dotnet publish --configuration Release --no-build src/DqtApi/DqtApi.csproj

    - name: Docker image tag
      id: image
      run: |
        echo ::set-output name=tag::$CONTAINER_REGISTRY/$(echo $GITHUB_REPOSITORY | tr '[:upper:]' '[:lower:]'):$GITHUB_SHA

    - name: Login to GitHub Container Registry
      uses: docker/login-action@v1
      with:
        registry: ${{ env.CONTAINER_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Docker build & push
      uses: docker/build-push-action@v2
      with:
        context: .
        push: true
        tags: ${{ steps.image.outputs.tag }}

  validate_terraform:
    name: Validate Terraform
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - uses: hashicorp/setup-terraform@v1
      with:
        terraform_version: 1.0.10

    - name: Check formatting
      run: terraform fmt -check
      working-directory: terraform

    - name: Validate
      run: |
        terraform init -backend=false
        terraform validate -no-color
      working-directory: terraform

    - name: Lint
      uses: reviewdog/action-tflint@master
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        tflint_rulesets: azurerm
        working_directory: terraform
      continue-on-error: true  # temporary- we're getting sporadic 503 errors here in action setup

  deploy_dev:
    name: Deploy to dev environment
    needs: [build, validate_terraform]
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.pull_request.draft == false
    environment:
      name: dev
      url: ${{ steps.deploy.outputs.environment_url }}
    concurrency: deploy_dev

    outputs:
      environment_url: ${{ steps.deploy.outputs.environment_url }}

    steps:
    - uses: actions/checkout@v2

    - uses: ./.github/workflows/actions/deploy-environment
      id: deploy
      with:
        environment_name: dev
        docker_image: ${{ needs.build.outputs.docker_image }}
        azure_credentials: ${{ secrets.AZURE_CREDENTIALS }}
        terraform_vars: dev.tfvars.json
        terraform_backend_vars: dev.backend.tfvars

  zap_scan:
    name: OWASP ZAP API scan
    needs: deploy_dev
    runs-on: ubuntu-latest
    concurrency: deploy_dev

    steps:
    - name: Create config file
      run: |
        echo "replacer.full_list(0).description=auth1" >> options.prop
        echo "replacer.full_list(0).enabled=true" >> options.prop
        echo "replacer.full_list(0).matchtype=REQ_HEADER" >> options.prop
        echo "replacer.full_list(0).matchstr=Authorization" >> options.prop
        echo "replacer.full_list(0).regex=false" >> options.prop
        echo "replacer.full_list(0).replacement=Bearer ${{ needs.deploy_dev.outputs.test_user_api_key }}" >> options.prop

    - uses: zaproxy/action-api-scan@v0.1.0
      with:
        target: ${{ needs.deploy_dev.outputs.environment_url }}swagger/v1/swagger.json
        format: openapi
        allow_issue_writing: false
        fail_action: true
        cmd_options: '-z "-configFile /zap/wrk/options.prop"'

  deploy_test:
    name: Deploy to test environment
    needs: [build, validate_terraform]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment:
      name: test
      url: ${{ steps.deploy.outputs.environment_url }}
    concurrency: deploy_test

    outputs:
      environment_url: ${{ steps.deploy.outputs.environment_url }}

    steps:
    - uses: actions/checkout@v2

    - uses: ./.github/workflows/actions/deploy-environment
      id: deploy
      with:
        environment_name: test
        docker_image: ${{ needs.build.outputs.docker_image }}
        azure_credentials: ${{ secrets.AZURE_CREDENTIALS }}
        terraform_vars: test.tfvars.json
        terraform_backend_vars: test.backend.tfvars

  deploy_preprod:
    name: Deploy to pre-production environment
    needs: [build, deploy_test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment:
      name: pre-production
      url: ${{ steps.deploy.outputs.environment_url }}
    concurrency: deploy_preprod

    outputs:
      environment_url: ${{ steps.deploy.outputs.environment_url }}

    steps:
    - uses: actions/checkout@v2

    - uses: ./.github/workflows/actions/deploy-environment
      id: deploy
      with:
        environment_name: pre-production
        docker_image: ${{ needs.build.outputs.docker_image }}
        azure_credentials: ${{ secrets.AZURE_CREDENTIALS }}
        terraform_vars: preprod.tfvars.json
        terraform_backend_vars: preprod.backend.tfvars

  deploy_prod:
    name: Deploy to production environment
    needs: [build, deploy_preprod]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: ${{ steps.deploy.outputs.environment_url }}
    concurrency: deploy_prod

    outputs:
      environment_url: ${{ steps.deploy.outputs.environment_url }}

    steps:
    - uses: actions/checkout@v2

    - uses: ./.github/workflows/actions/deploy-environment
      id: deploy
      with:
        environment_name: production
        docker_image: ${{ needs.build.outputs.docker_image }}
        azure_credentials: ${{ secrets.AZURE_CREDENTIALS }}
        terraform_vars: prod.tfvars.json
        terraform_backend_vars: prod.backend.tfvars
        skip_functional_tests: true
